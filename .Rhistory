out <- list()
for (p in params) {
mat_p <- try(as.matrix(fit, pars = p), silent = TRUE)
if (inherits(mat_p, "try-error") || is.null(mat_p) || ncol(mat_p) == 0) {
stop("Parameter '", p, "' not found in Stan fit.")
}
out[[p]] <- colMeans(mat_p)
}
as.data.frame(out)
}
# ---------------------------------------------
# 1) Load & merge true + recovered subject params
# ---------------------------------------------
generating_models <- names(param_config)
long_all <- purrr::map_dfr(generating_models, function(g) {
sim_path <- file.path(sim_dir, paste0("sim_", g, ".rds"))
if (!file.exists(sim_path)) {
warning("Missing ", sim_path, " — skipping ", g)
return(NULL)
}
sims <- readRDS(sim_path)
if (length(sims) < dataset_index) {
warning("No dataset ", dataset_index, " in ", sim_path, " — skipping ", g)
return(NULL)
}
sim_i   <- sims[[dataset_index]]
true_df <- sim_i$subject_parameters %>%
mutate(id = as.integer(id)) %>% arrange(id)
params <- param_config[[g]]
if (length(params) == 0) return(NULL)
fit_path <- file.path(fits_dir, paste0("fit_gen-", g, "_data-", dataset_index, "_cand-", g, ".rds"))
if (!file.exists(fit_path)) {
warning("Missing fit file: ", fit_path, " — skipping ", g)
return(NULL)
}
obj <- readRDS(fit_path)
if (is.null(obj$fit)) {
warning("No fit stored in: ", fit_path, " — skipping ", g)
return(NULL)
}
fit <- obj$fit
est_df <- extract_estimates(fit, params) %>%
dplyr::rename_with(~ paste0(.x, "_est"))
est_df <- tibble(id = true_df$id) %>% dplyr::bind_cols(est_df)
merged <- dplyr::inner_join(true_df, est_df, by = "id")
have_params <- params[params %in% names(merged) & paste0(params, "_est") %in% names(merged)]
if (!length(have_params)) return(NULL)
cols_to_pivot <- c(have_params, paste0(have_params, "_est"))
tidyr::pivot_longer(
merged,
cols = tidyselect::all_of(cols_to_pivot),
names_to = "name", values_to = "value"
) %>%
mutate(
source = ifelse(grepl("_est$", name), "est", "true"),
param  = sub("_est$", "", name)
) %>%
select(id, param, source, value) %>%
tidyr::pivot_wider(names_from = source, values_from = value) %>%
mutate(generating_model = g) %>%
relocate(generating_model, id, param, true, est)
})
if (nrow(long_all) == 0) stop("No data to plot — check paths/files and param_config.")
# Force full grid structure:
# - keep all models in the requested order
# - keep all parameters (some panels will be empty)
long_all <- long_all %>%
mutate(
generating_model = factor(as.character(generating_model),
levels = generating_models,
labels = model_labels_parsed[generating_models]),
param = factor(as.character(param),
levels = param_levels,
labels = param_labels_parsed[param_levels])
)
# ---------------------------------------------
# 2) Panel statistics (r, p, N) and label anchors
# ---------------------------------------------
fmt_p <- function(p) {
out <- rep("NA", length(p))
ok  <- !is.na(p)
p2  <- p[ok]
lab <- ifelse(p2 < 1e-3, "<.001", sprintf("%.3f", p2))
lab <- sub("^0\\.", ".", lab)
lab <- sub("^<0\\.", "<.", lab)
out[ok] <- lab
out
}
panel_stats <- long_all %>%
group_by(generating_model, param) %>%
summarise(
n = sum(complete.cases(true, est)),
r = {
ok <- complete.cases(true, est)
if (sum(ok) >= 3 && var(true[ok]) > 0 && var(est[ok]) > 0)
suppressWarnings(unname(cor(true[ok], est[ok], method = "pearson")))
else NA_real_
},
p = {
ok <- complete.cases(true, est)
if (sum(ok) >= 3 && var(true[ok]) > 0 && var(est[ok]) > 0)
suppressWarnings(cor.test(true[ok], est[ok], method = "pearson")$p.value)
else NA_real_
},
x = quantile(true, 0.05, na.rm = TRUE),
y = quantile(est,  0.95, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(
lbl = paste0("r = ", ifelse(is.na(r), "NA", sprintf("%.2f", r)),
"\n", "p = ", fmt_p(p)
#"\nN = ", n
),
x = -Inf,   # pin to left edge
y =  Inf    # pin to top edge
)
# ---------------------------------------------
# 3) Plot: truly free axes; empty panels kept & blank
# ---------------------------------------------
p_corr_grid <-
ggplot() +
# draw 45° line without a dataset so it can't affect scales
geom_abline(
data = data.frame(),
slope = 1, intercept = 0,
linetype = 2, linewidth = 0.5, color = "grey45"
) +
geom_point(
data = long_all,
aes(x = true, y = est),
alpha = point_alpha, size = point_size
) +
geom_smooth(
data = long_all,
aes(x = true, y = est),
method = "lm", se = TRUE, linewidth = 0.6
) +
geom_text(
data = panel_stats,
aes(x = x, y = y, label = lbl),
hjust = -0.1, vjust = 1.1, size = 3.2, color = "black",
inherit.aes = FALSE
) +
ggh4x::facet_grid2(
rows   = vars(generating_model),
cols   = vars(param),
scales = "free",          # free x & y in every panel
independent = "all",      # independent across rows *and* cols
drop   = FALSE,           # keep empty panels
labeller = labeller(
generating_model = label_parsed,
param            = label_parsed
)
) +
labs(
title    = "Parameter recovery: True vs Recovered",
subtitle = "Rows = Generating model, Columns = Parameter",
x = "True value",
y = "Recovered value"
) +
theme_classic(base_size = 12) +
theme(
panel.background = element_blank(),   # blank background for empty panels
strip.background = element_blank(),
panel.grid.minor = element_blank()
)
print(p_corr_grid)
# ---- Paths ----
sim_dir  <- "data/recoveryAnalysis/simulations"
fits_dir <- "data/recoveryAnalysis/recovery"
# ---- Which parameters each model has (keep in sync with your Stan) ----
param_config <- list(
Reward       = c("tau"),
Theta        = c("tau", "theta"),
Omega        = c("tau", "omega"),
ThetaOmega   = c("tau", "theta", "omega"),
MotorSticky  = c("tau", "theta", "omega", "kappa"),
BanditSticky = c("tau", "theta", "omega", "kappa")
)
# ---- Pretty labels (Greek letters) for facet strip titles ----
param_labels <- c(
"theta" = "\u03B8",  # θ
"tau"   = "\u03C4",  # τ
"omega" = "\u03C9",  # ω
"kappa" = "\u03BA"   # κ
)
greek_labeller <- labeller(param = param_labels)
# ---- Config ----
generating_models <- names(param_config)
dataset_index     <- 1       # which dataset from each sim_*.rds to use
point_alpha       <- 0.65
point_size        <- 1.7
# ------------------------------------------------------------
# Helper: extract posterior means per subject for params
# ------------------------------------------------------------
extract_estimates <- function(fit, params) {
out <- list()
for (p in params) {
mat_p <- try(as.matrix(fit, pars = p), silent = TRUE)
if (inherits(mat_p, "try-error") || is.null(mat_p) || ncol(mat_p) == 0) {
stop("Parameter '", p, "' not found in Stan fit.")
}
out[[p]] <- colMeans(mat_p)  # one mean per subject
}
as.data.frame(out)
}
# ------------------------------------------------------------
# Build long data for ALL models: id, model, param, true, est
# ------------------------------------------------------------
# ------------------------------------------------------------
# Build long data for ALL models: id, model, param, true, est (robust, with _est suffix)
# ------------------------------------------------------------
long_all <- purrr::map_dfr(generating_models, function(g) {
sim_path <- file.path(sim_dir, paste0("sim_", g, ".rds"))
if (!file.exists(sim_path)) { warning("Missing ", sim_path, " — skipping ", g); return(NULL) }
sims <- readRDS(sim_path)
if (length(sims) < dataset_index) { warning("No dataset ", dataset_index, " in ", sim_path, " — skipping ", g); return(NULL) }
sim_i   <- sims[[dataset_index]]
true_df <- sim_i$subject_parameters %>% mutate(id = as.integer(id)) %>% arrange(id)
params <- param_config[[g]]
if (is.null(params) || length(params) == 0) return(NULL)
fit_path <- file.path(fits_dir, paste0("fit_gen-", g, "_data-", dataset_index, "_cand-", g, ".rds"))
if (!file.exists(fit_path)) { warning("Missing fit file: ", fit_path, " — skipping ", g); return(NULL) }
obj <- readRDS(fit_path)
if (is.null(obj$fit)) { warning("No fit stored in: ", fit_path, " — skipping ", g); return(NULL) }
fit <- obj$fit
# Posterior means per subject
est_df <- extract_estimates(fit, params)             # columns named like 'tau','theta',...
est_df <- est_df %>% dplyr::rename_with(~ paste0(.x, "_est"))  # now 'tau_est','theta_est',...
est_df <- tibble::tibble(id = true_df$id) %>% dplyr::bind_cols(est_df)
merged <- dplyr::inner_join(true_df, est_df, by = "id")
# Only keep params that exist as both true and _est
have_params <- params[params %in% names(merged) & paste0(params, "_est") %in% names(merged)]
if (!length(have_params)) {
warning("No matching true/est parameters for model ", g,
". Present cols: ", paste(names(merged), collapse = ", "))
return(NULL)
}
missing_params <- setdiff(params, have_params)
if (length(missing_params)) message("Model ", g, ": skipping missing params -> ",
paste(missing_params, collapse = ", "))
cols_to_pivot <- c(have_params, paste0(have_params, "_est"))
out_long <- tidyr::pivot_longer(
merged,
cols = tidyselect::all_of(cols_to_pivot),
names_to = "name",
values_to = "value"
) %>%
dplyr::mutate(
source = ifelse(grepl("_est$", name), "est", "true"),
param  = sub("_est$", "", name)
) %>%
dplyr::select(id, param, source, value) %>%
tidyr::pivot_wider(names_from = source, values_from = value) %>%
dplyr::mutate(generating_model = g) %>%
dplyr::relocate(generating_model, id, param, true, est)
out_long
})
if (nrow(long_all) == 0) stop("No data to plot — check paths/files above.")
# Keep a consistent param order across columns
param_order <- c("theta", "tau", "omega", "kappa")
present_params <- intersect(param_order, unique(long_all$param))
long_all <- long_all %>%
filter(param %in% present_params) %>%
mutate(
param = factor(param, levels = present_params),
generating_model = factor(generating_model, levels = generating_models)
)
# ------------------------------------------------------------
# Compute per-panel Pearson r for nice labels
# ------------------------------------------------------------
panel_stats <- long_all %>%
group_by(generating_model, param) %>%
summarise(
n = sum(complete.cases(true, est)),
r = if (n >= 3 && var(true, na.rm = TRUE) > 0 && var(est, na.rm = TRUE) > 0)
cor(true, est, use = "complete.obs") else NA_real_,
# label anchor (upper-left-ish)
x = quantile(true, 0.05, na.rm = TRUE),
y = quantile(est,  0.95, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(lbl = paste0("r = ", ifelse(is.na(r), "NA", sprintf("%.2f", r)),
"\nN = ", n))
# ------------------------------------------------------------
# Plot: one big grid (rows=models, cols=params)
# ------------------------------------------------------------
p_corr_grid <- ggplot(long_all, aes(x = true, y = est)) +
geom_abline(slope = 1, intercept = 0, linetype = 2, linewidth = 0.5, color = "grey45") +
geom_point(alpha = point_alpha, size = point_size) +
geom_smooth(method = "lm", se = TRUE, linewidth = 0.6) +
facet_grid(generating_model ~ param, scales = "free", labeller = labeller(param = param_labels)) +
labs(
title = "Parameter recovery: true vs recovered (posterior mean)",
subtitle = "Rows = generating model, Columns = parameter; dashed line is y = x",
x = "True value",
y = "Recovered value"
) +
theme_minimal(base_size = 12) +
theme(
panel.grid.minor = element_blank(),
strip.background = element_rect(fill = "grey95", color = NA)
) +
# r & N overlay
geom_text(
data = panel_stats,
aes(x = x, y = y, label = lbl),
inherit.aes = FALSE,
hjust = 0, vjust = 1, size = 3.2
)
print(p_corr_grid)
library(ggh4x)
suppressPackageStartupMessages({
library(rstan)
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
library(tibble)
library(ggh4x)
})
# Paths & config
sim_dir  <- "data/recoveryAnalysis/simulations"   # sim_<MODEL>.rds
fits_dir <- "data/recoveryAnalysis/recovery"      # fit_gen-<MODEL>_data-<i>_cand-<MODEL>.rds
dataset_index <- 1
# specifiy parameters each model has
param_config <- list(
Reward       = c("tau"),
Theta        = c("tau", "theta"),
Omega        = c("tau", "omega"),
ThetaOmega   = c("tau", "theta", "omega"),
MotorSticky  = c("tau", "theta", "omega", "kappa"),
BanditSticky = c("tau", "theta", "omega", "kappa")
)
# order of columns
param_levels <- c("tau", "theta","omega", "kappa")
# recode
model_labels_parsed <- c(
Reward       = "R - ~ 'Only'",
Theta        = "R - ~ theta",
Omega        = "R - ~ omega",
ThetaOmega   = "R - ~ theta*omega",
MotorSticky  = "R - ~ theta*omega*rho[s]",
BanditSticky = "R - ~ theta*omega*rho[m]"
)
param_labels_parsed <- c(
tau   = "tau",
theta = "theta",
omega = "omega",
kappa = "rho"
)
point_alpha <- 0.65
point_size  <- 1.7
# Helper to extract from stan fits
extract_estimates <- function(fit, params) {
out <- list()
for (p in params) {
mat_p <- try(as.matrix(fit, pars = p), silent = TRUE)
if (inherits(mat_p, "try-error") || is.null(mat_p) || ncol(mat_p) == 0) {
stop("Parameter '", p, "' not found in Stan fit.")
}
out[[p]] <- colMeans(mat_p)
}
as.data.frame(out)
}
# Load
generating_models <- names(param_config)
long_all <- purrr::map_dfr(generating_models, function(g) {
sim_path <- file.path(sim_dir, paste0("sim_", g, ".rds"))
if (!file.exists(sim_path)) {
warning("Missing ", sim_path, " — skipping ", g)
return(NULL)
}
sims <- readRDS(sim_path)
if (length(sims) < dataset_index) {
warning("No dataset ", dataset_index, " in ", sim_path, " — skipping ", g)
return(NULL)
}
sim_i   <- sims[[dataset_index]]
true_df <- sim_i$subject_parameters %>%
mutate(id = as.integer(id)) %>% arrange(id)
params <- param_config[[g]]
if (length(params) == 0) return(NULL)
fit_path <- file.path(fits_dir, paste0("fit_gen-", g, "_data-", dataset_index, "_cand-", g, ".rds"))
if (!file.exists(fit_path)) {
warning("Missing fit file: ", fit_path, " — skipping ", g)
return(NULL)
}
obj <- readRDS(fit_path)
if (is.null(obj$fit)) {
warning("No fit stored in: ", fit_path, " — skipping ", g)
return(NULL)
}
fit <- obj$fit
est_df <- extract_estimates(fit, params) %>%
dplyr::rename_with(~ paste0(.x, "_est"))
est_df <- tibble(id = true_df$id) %>% dplyr::bind_cols(est_df)
merged <- dplyr::inner_join(true_df, est_df, by = "id")
have_params <- params[params %in% names(merged) & paste0(params, "_est") %in% names(merged)]
if (!length(have_params)) return(NULL)
cols_to_pivot <- c(have_params, paste0(have_params, "_est"))
tidyr::pivot_longer(
merged,
cols = tidyselect::all_of(cols_to_pivot),
names_to = "name", values_to = "value"
) %>%
mutate(
source = ifelse(grepl("_est$", name), "est", "true"),
param  = sub("_est$", "", name)
) %>%
select(id, param, source, value) %>%
tidyr::pivot_wider(names_from = source, values_from = value) %>%
mutate(generating_model = g) %>%
relocate(generating_model, id, param, true, est)
})
if (nrow(long_all) == 0) stop("No data to plot — check paths/files and param_config.")
long_all <- long_all %>%
mutate(
generating_model = factor(as.character(generating_model),
levels = generating_models,
labels = model_labels_parsed[generating_models]),
param = factor(as.character(param),
levels = param_levels,
labels = param_labels_parsed[param_levels])
)
fmt_p <- function(p) {
out <- rep("NA", length(p))
ok  <- !is.na(p)
p2  <- p[ok]
lab <- ifelse(p2 < 1e-3, "<.001", sprintf("%.3f", p2))
lab <- sub("^0\\.", ".", lab)
lab <- sub("^<0\\.", "<.", lab)
out[ok] <- lab
out
}
panel_stats <- long_all %>%
group_by(generating_model, param) %>%
summarise(
n = sum(complete.cases(true, est)),
r = {
ok <- complete.cases(true, est)
if (sum(ok) >= 3 && var(true[ok]) > 0 && var(est[ok]) > 0)
suppressWarnings(unname(cor(true[ok], est[ok], method = "pearson")))
else NA_real_
},
p = {
ok <- complete.cases(true, est)
if (sum(ok) >= 3 && var(true[ok]) > 0 && var(est[ok]) > 0)
suppressWarnings(cor.test(true[ok], est[ok], method = "pearson")$p.value)
else NA_real_
},
x = quantile(true, 0.05, na.rm = TRUE),
y = quantile(est,  0.95, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(
lbl = paste0("r = ", ifelse(is.na(r), "NA", sprintf("%.2f", r)),
"\n", "p = ", fmt_p(p)
#"\nN = ", n
),
x = -Inf,   # pin to left edge
y =  Inf    # pin to top edge
)
# Plot
p_corr_grid <-
ggplot() +
# need to draw 45° line without a dataset so it doesnt affect scaling
geom_abline(
data = data.frame(),
slope = 1, intercept = 0,
linetype = 2, linewidth = 0.5, color = "grey45"
) +
geom_point(
data = long_all,
aes(x = true, y = est),
alpha = point_alpha, size = point_size
) +
geom_smooth(
data = long_all,
aes(x = true, y = est),
method = "lm", se = TRUE, linewidth = 0.6
) +
geom_text(
data = panel_stats,
aes(x = x, y = y, label = lbl),
hjust = -0.1, vjust = 1.1, size = 3.2, color = "black",
inherit.aes = FALSE
) +
ggh4x::facet_grid2(
rows   = vars(generating_model),
cols   = vars(param),
scales = "free",          # free x & y in every panel
independent = "all",
drop   = FALSE,
labeller = labeller(
generating_model = label_parsed,
param            = label_parsed
)
) +
labs(
title    = "Parameter recovery: True vs Recovered",
subtitle = "Rows = Generating model, Columns = Parameter",
x = "True value",
y = "Recovered value"
) +
theme_classic(base_size = 12) +
theme(
panel.background = element_blank(),
strip.background = element_blank(),
panel.grid.minor = element_blank()
)
print(p_corr_grid)
